
#include <stdio.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "nvs_flash.h"
#include "esp_netif.h"
#include "mqtt_client.h"
#include "minimal_wifi.h"
#include "driver/adc.h"
#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_log.h"

// Wi-Fi and MQTT 
#define WIFI_SSID   "Tufts_Wireless"
#define WIFI_PASS   ""
#define BROKER_URI  "mqtt://bell-mqtt.eecs.tufts.edu"
#define TAG "THERM+MQTT"

// ADC (Thermistor) 
#define THERM_CH   ADC1_CHANNEL_0
#define LED_PIN    GPIO_NUM_8

#define VREF_V     3.3f
#define R_SERIES   10000.0f
#define R_NOM      10000.0f
#define T_NOM_C    25.0f
#define BETA       3380.0f
#define AVG_N      16

// I²C (TMP1075) 
#define I2C_MASTER_PORT     I2C_NUM_0
#define I2C_MASTER_FREQ_HZ  100000
#define SDA_PIN             4
#define SCL_PIN             5
#define TMP1075_ADDR        0x48      
#define TMP1075_TEMP_REG    0x00
#define TMP1075_RESOLUTION  0.0625f  

// Raw ADC readings
static int read_avg_raw(adc1_channel_t ch) {
    int sum = 0;
    for (int i = 0; i < AVG_N; i++) sum += adc1_get_raw(ch);
    return (sum + AVG_N/2) / AVG_N;
}

// Initialize I2C
static void i2c_master_init(void) {
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SDA_PIN,
        .scl_io_num = SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = I2C_MASTER_FREQ_HZ,
    };
    ESP_ERROR_CHECK(i2c_param_config(I2C_MASTER_PORT, &conf));
    ESP_ERROR_CHECK(i2c_driver_install(I2C_MASTER_PORT, conf.mode, 0, 0, 0));
}

// Read temperature (°C) from TMP1075
static float tmp1075_read_temp(void) {
    uint8_t reg = TMP1075_TEMP_REG;
    uint8_t buf[2];

    esp_err_t err = i2c_master_write_read_device(
        I2C_MASTER_PORT,
        TMP1075_ADDR,
        &reg, 1,
        buf, 2,
        pdMS_TO_TICKS(100)
    );

    if (err != ESP_OK) {
        ESP_LOGE(TAG, "TMP1075 read failed: %s", esp_err_to_name(err));
        return NAN;
    }

    int16_t raw = ((int16_t)buf[0] << 8) | buf[1];
    raw >>= 4;                       
    if (raw & 0x800) raw |= 0xF000;  
    return raw * TMP1075_RESOLUTION;
}

// Main

void app_main(void)
{
//    // LED
//     gpio_reset_pin(LED_PIN);
//     gpio_set_direction(LED_PIN, GPIO_MODE_OUTPUT);
//     gpio_set_level(LED_PIN, 1);

    // ADC
    adc1_config_width(ADC_WIDTH_BIT_12);
    adc1_config_channel_atten(THERM_CH, ADC_ATTEN_DB_11);

    // I2C
    i2c_master_init();

    // Wifi and MQTT
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ESP_ERROR_CHECK(nvs_flash_init());
    }
    wifi_connect(WIFI_SSID, WIFI_PASS);

    esp_mqtt_client_config_t mqtt_cfg = { .broker.address.uri = BROKER_URI };
    esp_mqtt_client_handle_t client = esp_mqtt_client_init(&mqtt_cfg);
    esp_mqtt_client_start(client);

    ESP_LOGI(TAG, "Setup complete — starting measurement loop...");

    while (1) {
        // Thermistor 
        int raw = read_avg_raw(THERM_CH);
        float v = raw / 4095.0f * VREF_V;
        float r = (v * R_SERIES) / (VREF_V - v);
        float T0K = T_NOM_C + 273.15f;
        float invT = (1.0f/T0K) + (1.0f/BETA) * logf(r / R_NOM);
        float tC = 1.0f/invT - 273.15f;

        ESP_LOGI(TAG, "Thermistor: %.2f °C", tC);

        char msg[32];
        snprintf(msg, sizeof(msg), "%.2f", tC);
        esp_mqtt_client_publish(client, "lberub01/iteration1/thermistor_temp", msg, 0, 0, 0);

        // TMP1075
        float t_ic = tmp1075_read_temp();
        if (!isnan(t_ic)) {
            ESP_LOGI(TAG, "TMP1075: %.2f °C", t_ic);
            char msg_ic[32];
            snprintf(msg_ic, sizeof(msg_ic), "%.2f", t_ic);
            esp_mqtt_client_publish(client, "lberub01/iteration1/ic_temp", msg_ic, 0, 0, 0);
        }

        vTaskDelay(pdMS_TO_TICKS(1800000));
    }
}
